#!/bin/sh
# OCF Resource Agent compliant beegfs-monitor script.
#
# License: BSD-3-Clause
# Author: Nathan Swartz

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

###############################################################################

# Returns whether the resource is active.
check_resource_service() {
  #if systemctl is-active "$service"; then
  if systemctl --state=active,running list-units "$service" | grep "$service"; then
    return 0
  fi

  ocf_log warn "Resource service is not active!"
  return 1
}

# Return network communication interface name(s) from the BeeGFS resource's connInterfaceFile
get_interfaces() {
  # Determine BeeGFS service network IP interfaces.
  connInterfacesFile_path=$(grep "^connInterfacesFile" "$conf_path" | cut -f 2 -d "=")
  if [ -f $connInterfacesFile_path ]; then
    cat $connInterfacesFile_path | while IFS= read -r line; do echo "$line" | cut -d ':' -f 1; done
  fi
}

# Return list containing all the BeeGFS resource's usable IP addresses. *Note that these are filtered by the connNetFilterFile entries.
get_subnet_ips() {
  # Determine all possible BeeGFS service network IP addresses.
  connNetFilterFile_path=$(grep "^connNetFilterFile" "$conf_path" | cut -f 2 -d "=")
  filter_ips=""
  if [ -f $connNetFilterFile_path ]; then
    for filter in $(cat $connNetFilterFile_path); do
      filter_ips_cmd="from ipaddress import ip_network; ips=[str(ip) for ip in ip_network(u'${filter}')]; print(' '.join(ips))"
      filter_ips="$filter_ips $(echo "$filter_ips_cmd" | python)"
    done
    echo "$filter_ips"
  fi
}

# Ping specified IP address from select interface until successful or retries are exhausted.
ping_interface() {
  test_interface=$1
  test_address=$2

  for _ in $(seq 1 $ping_count); do
    if ping -I $test_interface -W $ping_timeout -c 1 $test_address; then
      echo 0
    fi
  done
}

# Returns whether at least one of the BeeGFS resource group's communication interface(s) are able to communicate on the network.
check_network_connectivity() {

  # Test network interfaces by pinging previously used IP addresses per interface
  interfaces=$(get_interfaces)
  filter_ips=$(get_subnet_ips)

  # Monitor for interface activity
  ip_monitor_stdout=$(timeout $monitor_timeout ip monitor)
  for interface in $interfaces; do
    if echo $ip_monitor_stdout | grep "$interface.*REACHABLE"; then
      return $OCF_SUCCESS
    fi
  done

  # Ping each interface using ip neighbors in the background
  true > /tmp/~beegfs-monitor-$group-ping_interface_results
  for interface in $interfaces; do
    for neighbor_entry in $(ip neigh show dev $interface | grep -E "(REACHABLE|STALE)" | sort '-t ' -k 4 | cut -d ' ' -f 1 | head -n $ping_max_count); do
      if [ -n "$filter_ips" ]; then
        for filter_ip in $filter_ips; do
          if [ $neighbor_entry = $filter_ip ]; then
            ping_interface $interface $neighbor_entry >> /tmp/~beegfs-monitor-$group-ping_interface_results &
          fi
        done
      else
        ping_interface $interface $neighbor_entry >> /tmp/~beegfs-monitor-$group-ping_interface_results &
      fi
    done
  done

  # Evaluate ping results
  for _ in $(seq 0 $ping_count); do
    if grep "0" /tmp/~beegfs-monitor-$group-ping_interface_results > /dev/null; then
      rm -f /tmp/~beegfs-monitor-$group-ping_interface_results
      return $OCF_SUCCESS
    fi
    sleep $ping_timeout
  done

  ocf_log warn "Resource interfaces are not reachable!"
  rm -f /tmp/~beegfs-monitor-$group-ping_interface_results
  return $OCF_ERR_GENERIC
}

# Return network communication interface name(s) from the BeeGFS resource's connInterfaceFile
check_filesystem_mounts() {
  mounts=$(grep "^storeStorageDirectory" "$conf_path" | cut -f 2 -d "=" | sed 's/\/data//g' | sed 's/,/ /')
  for mount in $mounts; do
    if ! (mount | grep "$mount" > /dev/null) || ! (ls "$mount" > /dev/null) && ! (df --sync "$mount" > /dev/null); then
      ocf_log warn "Resource mounts are not available!"
      return $OCF_ERR_GENERIC
    fi
  done
  return $OCF_SUCCESS
}

###############################################################################

# Output the usage information
beegfs_monitor_usage() {
  cat <<END
Usage: $0 (start|stop|monitor|meta-data|validate-all)

Requires: ping, ip
Parameters:
  service_type                  (Required) Beegfs service (Choices: management, metadata, storage)
  service_name                  (Required) BeeGFS service name
  service_configuration_mount   (Required) BeeGFS service configuration mount path
  monitor_timeout_sec           Timeout measured in seconds for the monitoring interface connections (Default 120)
  ping_count                    Number of times attempt to ping IP address (Default 3)
  ping_timeout_sec              Individual ping timeout measured in seconds (Default 2)

* BeeGFS resource group should be co-located with this monitoring service. Where beegfs-monitor goes so does the
  resource group; this allows the group to be fenced when monitoring fails to return successfully.
END
}

# Output the meta-data XML
beegfs_monitor_meta_data() {
  cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="beegfs-monitor">
  <version>1.0</version>
  <longdesc lang="en">This resource agent monitors a single BeeGFS service.</longdesc>
  <shortdesc lang="en">BeeGFS service monitor</shortdesc>
  <parameters>
    <parameter name="service_group" unique="1" required="0">
      <longdesc lang="en">The BeeGFS resource group name.</longdesc>
      <shortdesc lang="en">BeeGFS service group name</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="service_type" unique="1" required="0">
      <longdesc lang="en">Type of BeeGFS service which can be one of the following: management, metadata, storage.</longdesc>
      <shortdesc lang="en">BeeGFS service type</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="service_name" unique="1" required="0">
      <longdesc lang="en">Name of the BeeGFS systemd service to monitor.</longdesc>
      <shortdesc lang="en">BeeGFS service name</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="service_configuration_mount" unique="1" required="0">
      <longdesc lang="en">Path to the BeeGFS service configuration file.</longdesc>
      <shortdesc lang="en">BeeGFS service configuration file</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="monitor_timeout_sec" unique="1" required="1">
      <longdesc lang="en">Timeout measured in seconds for the monitoring interface connections.</longdesc>
      <shortdesc lang="en">Timeout for interface monitoring.</shortdesc>
      <content type="integer" default="120"/>
    </parameter>
    <parameter name="ping_count" unique="1" required="1">
      <longdesc lang="en">Number of ping attempts before considering the IP address unreachable from the interface.</longdesc>
      <shortdesc lang="en">Ping count</shortdesc>
      <content type="integer" default="3"/>
    </parameter>
    <parameter name="ping_timeout_sec" unique="1" required="1">
      <longdesc lang="en">Timeout for individual ping requests.</longdesc>
      <shortdesc lang="en">Ping timeout</shortdesc>
      <content type="integer" default="2"/>
    </parameter>
    <parameter name="ping_max_count" unique="1" required="1">
      <longdesc lang="en">Maximum number of addresses to test. These tests will continue until either a ping is successful or the maximum ping count is reached.</longdesc>
      <shortdesc lang="en">Maximum ping tests.</shortdesc>
      <content type="integer" default="3"/>
    </parameter>
  </parameters>
  <actions>
    <action name="start"          timeout="60" />
    <action name="stop"           timeout="10" />
    <action name="monitor"        timeout="60" interval="60" depth="0" />
    <action name="meta-data"      timeout="5" />
    <action name="validate-all"   timeout="10" />
  </actions>
</resource-agent>
END
}

# Wait for BeeGFS service to start.
beegfs_monitor_start() {
  # Don't block this task! If you do then the remaining group resources will not start.
  ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} start
  return $OCF_SUCCESS
}

# Wait for BeeGFS service to stop.
beegfs_monitor_stop() {
  # Don't block this task! If you do then the remaining group resources will not stop.
  ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} stop
  return $OCF_SUCCESS
}

# Validate BeeGFS service is running.
beegfs_monitor_monitor() {

  # Check resource tracking file.
  ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} monitor
  ha_pseudo_resource_status=$?
  if [ $ha_pseudo_resource_status -ne $OCF_SUCCESS ]; then
    ocf_log warn "Whoops! ha_pseudo_resource_status: $ha_pseudo_resource_status"
    return $ha_pseudo_resource_status
  fi

  # Validate BeeGFS service and network connectivity.
  #total_attempt=$(( monitor_timeout / 5 + 1))
  #attempt=0
  #while [ $attempt -ne $total_attempt ]; do
  #  #if check_filesystem_mounts && check_network_connectivity && check_resource_service; then
  #  # Issues: check_resource_service
  #  if check_filesystem_mounts; then
  #    return $OCF_SUCCESS
  #  fi
  #
  #  ocf_log warn "Resource monitoring failed...Attempt $attempt."
  #  sleep $(( attempt * attempt + 1))
  #  attempt=$(( attempt + 1))
  #done

  #if check_filesystem_mounts && check_network_connectivity && check_resource_service; then
  #  return $OCF_SUCCESS
  #elif check_resource_service; then
  #  ocf_log warn "Resource monitoring failed but check_resource_service succeeded..."
  #  return $OCF_SUCCESS
  #elif check_network_connectivity; then
  #  ocf_log warn "Resource monitoring failed but check_network_connectivity succeeded..."
  #  return $OCF_SUCCESS
  #elif check_filesystem_mounts; then
  #  ocf_log warn "Resource monitoring failed but check_filesystem_mounts succeeded.."
  #  return $OCF_SUCCESS
  #fi
  #ocf_log warn "Resource monitoring failed..."

  return $OCF_SUCCESS
  #return $OCF_ERR_GENERIC
}

# Validate beegfs-monitor requirements
beegfs_monitor_validate_all() {
  return $OCF_SUCCESS
}

###############################################################################

# Provide information for metadata and usage requests
case $__OCF_ACTION in
  meta-data)
    beegfs_monitor_meta_data
    exit $OCF_SUCCESS
    ;;
  usage|help)
    beegfs_monitor_usage
    exit $OCF_SUCCESS
    ;;
esac


# Set argument variables
monitor_timeout=${OCF_RESKEY_monitor_timeout_sec:-120}
ping_count=${OCF_RESKEY_ping_count:-3}
ping_timeout=${OCF_RESKEY_ping_timeout_sec:-2}
ping_max_count=${OCF_RESKEY_ping_max_count:-3}
group=${OCF_RESKEY_service_group:-""}
type=${OCF_RESKEY_service_type:-""}
service=${OCF_RESKEY_service_name:-""}
configuration_mount=${OCF_RESKEY_service_configuration_mount:-""}
configuration_mount=${configuration_mount%%/}

case $type in
  management)
    conf_path="${configuration_mount}/mgmt_config/beegfs-mgmtd.conf"
    ;;
  metadata)
    conf_path="${configuration_mount}/metadata_config/beegfs-meta.conf"
    ;;
  storage)
    conf_path="${configuration_mount}/storage_config/beegfs-storage.conf"
    ;;
  *)
    beegfs_monitor_usage
    exit $OCF_ERR_ARGS
    ;;
esac


# Perform action requests
case $__OCF_ACTION in
  start)
    beegfs_monitor_start
    ;;
  stop)
    beegfs_monitor_stop
    ;;
  monitor)
    beegfs_monitor_monitor
    ;;
  validate-all)
    ;;
  *)
    beegfs_monitor_usage
    exit $OCF_ERR_UNIMPLEMENTED
    ;;
esac

rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION returned $rc"
exit $rc
