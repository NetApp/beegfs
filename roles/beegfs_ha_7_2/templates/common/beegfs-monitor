#!/bin/bash
# OCF Resource Agent compliant beegfs-monitor script.
#
# License: BSD-3-Clause
# Author: Nathan Swartz

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

###############################################################################
# Helper functions

convert_ipv4_address_to_int() {
  echo "$1" | awk '''
  {
    split($0, parts, "/")
    cidr=parts[2]
    split(parts[1], octets, ".")
    address_int=octets[1]*16777216 + octets[2]*65536 + octets[3]*256 + octets[4]
    printf address_int
  }
  '''
}

convert_int_to_ipv4_address() {
  echo "$1" | awk '''
  {
    address_int=$0
    v1=lshift(rshift(address_int, 24), 24)
    v2=lshift(rshift(address_int - v1, 16), 16)
    v3=lshift(rshift(address_int - v1 - v2, 8), 8)
    v4= address_int - v1 - v2 - v3
    octet1 = v1 / 16777216
    octet2 = v2 / 65536
    octet3 = v3 / 256
    octet4 = v4
    printf octet1"."octet2"."octet3"."octet4" "
  }
  '''
}

get_ipv4_subnet_addresses() {
  cidr_subnet=$1
  base_address=$(echo $cidr_subnet | cut -f 1 -d '/' )
  subnet=$(echo $cidr_subnet | cut -f 2 -d '/' )

  start_address_int=$(convert_ipv4_address_to_int $base_address)
  end_address_int=$(( $start_address_int + 2 ** (32 - $subnet) - 1 ))
  for address_int in $(seq $start_address_int $end_address_int); do
    convert_int_to_ipv4_address $address_int
  done
}

check_resource_service() {
  if systemctl is-active "$service" > /dev/null 2>&1; then
    return 0
  fi

  return 1
}

# Return network communication interface name(s) from the BeeGFS resource's connInterfaceFile
get_mgmt_ip() {
  if [ "$type" != "management" ]; then
    grep "^sysMgmtdHost" "$conf_path" | tr -d "[:space:]" | cut -f 2 -d "="
  fi
}

# Return network communication interface name(s) from the BeeGFS resource's connInterfaceFile
get_interfaces() {
  # Determine BeeGFS service network IP interfaces.
  connInterfacesFile_path=$(grep "^connInterfacesFile" "$conf_path" | tr -d "[:space:]" | cut -f 2 -d "=")

  interfaces=""
  if [ -n "$connInterfacesFile_path" ] && [ -e $connInterfacesFile_path ]; then
    while read -r entry; do
      interface=$(echo "$entry" | cut -d ":" -f 1)
      interfaces="$interfaces $interface"
    done < $connInterfacesFile_path
  fi

  echo "$interfaces"
}

# Return list containing all the BeeGFS resource's usable IP addresses. *Note that these are filtered by the connNetFilterFile entries.
get_subnet_ips() {
  # Determine all possible BeeGFS service network IP addresses.
  connNetFilterFile_path=$(grep "^connNetFilterFile" "$conf_path" | tr -d "[:space:]" | cut -f 2 -d "=")

  filter_ips=""
  if [ -n "$connNetFilterFile_path" ] && [ -e $connNetFilterFile_path ]; then
    while read -r filter; do
      filter_ips="$filter_ips $(get_ipv4_subnet_addresses $filter)"
    done < $connNetFilterFile_path
  fi

  echo "$filter_ips"
}

# Ping specified IP address from select interface until successful or retries are exhausted.
ping_interface() {
  test_interface=$1
  test_address=$2

  for _ in $(seq 1 "$ping_count"); do
    if ping -I "$test_interface" -W "$ping_timeout" -c 1 "$test_address" > /dev/null 2>&1 ; then
      echo 0
    fi
  done
}

# Returns whether at least one of the BeeGFS resource group's communication interface(s) are able to communicate on the network.
check_network_connectivity() {

  # Test network interfaces by pinging previously used IP addresses per interface
  interfaces=$(get_interfaces)
  filter_ips=$(get_subnet_ips)

  # Ping each interface using ip neighbors in the background
  true > /tmp/~beegfs-monitor-$group-ping_interface_results
  for interface in $interfaces; do
    neighbor_entries=$(ip neigh show dev $interface | grep -E "(REACHABLE|STALE)" | sort '-t ' -k 4 | cut -d ' ' -f 1 | head -n "$ping_max_count")
    neighbor_entries="$neighbor_entries $(get_mgmt_ip)"
    for neighbor_entry in $neighbor_entries; do
      if [ -n "$filter_ips" ]; then
        for filter_ip in $filter_ips; do
          if [ "$neighbor_entry" = "$filter_ip" ]; then
            ping_interface "$interface" "$neighbor_entry" >> "/tmp/~beegfs-monitor-$group-ping_interface_results" &
          fi
        done
      else
        ping_interface "$interface" "$neighbor_entry" >> "/tmp/~beegfs-monitor-$group-ping_interface_results" &
      fi
    done
  done

  # Evaluate ping results once pings are complete
  wait
  if [ -s "/tmp/~beegfs-monitor-$group-ping_interface_results" ]; then
    return 0
  fi

  return 1
}

# Return network communication interface name(s) from the BeeGFS resource's connInterfaceFile
check_filesystem_mounts() {
  mounts=$(grep "^store.*Directory" "$conf_path" 2> /dev/null | cut -f 2 -d "=" | sed 's/\/data//g' | sed 's/,/ /g')

  # Check mount information
  if [ -z "$mounts" ]; then
    return 1
  fi

  # Test mount information
  for mount in $mounts; do
    mount_device_path=$(mount | grep "$mount" | cut -f 1 -d ' ')

    # Check whether device is mounted.
    if [ -z "$mount_device_path" ]; then
      return 2

    # Check whether device is readable.
    elif ! (dd if=$mount_device_path iflag=direct bs=4k count=1 > /dev/null 2>&1); then
      return 3
    fi
  done

  return 0
}

###############################################################################

# Output the usage information
beegfs_monitor_usage() {
  cat <<END
Usage: $0 (start|stop|monitor|meta-data|validate-all)

Requires: ping, ip
Parameters:
  service_type                  (Required) Beegfs service (Choices: management, metadata, storage)
  service_name                  (Required) BeeGFS service name
  service_configuration_mount   (Required) BeeGFS service configuration mount path
  ping_count                    Number of times attempt to ping IP address (Default 1)
  ping_timeout_sec              Individual ping timeout measured in seconds (Default 1)

END
}

# Output the meta-data XML
beegfs_monitor_meta_data() {
  cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="beegfs-monitor">
  <version>1.0</version>
  <longdesc lang="en">This resource agent monitors a single BeeGFS service.</longdesc>
  <shortdesc lang="en">BeeGFS service monitor</shortdesc>
  <parameters>
    <parameter name="service_group" unique="1" required="0">
      <longdesc lang="en">The BeeGFS resource group name.</longdesc>
      <shortdesc lang="en">BeeGFS service group name</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="service_type" unique="0" required="0">
      <longdesc lang="en">Type of BeeGFS service which can be one of the following: management, metadata, storage.</longdesc>
      <shortdesc lang="en">BeeGFS service type</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="service_name" unique="0" required="0">
      <longdesc lang="en">Name of the BeeGFS systemd service to monitor.</longdesc>
      <shortdesc lang="en">BeeGFS service name</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="service_configuration_mount" unique="1" required="0">
      <longdesc lang="en">Path to the BeeGFS service configuration file.</longdesc>
      <shortdesc lang="en">BeeGFS service configuration file</shortdesc>
      <content type="string"/>
    </parameter>
    <parameter name="ping_count" unique="0" required="1">
      <longdesc lang="en">Number of ping attempts before considering the IP address unreachable from the interface.</longdesc>
      <shortdesc lang="en">Ping count</shortdesc>
      <content type="integer" default="1"/>
    </parameter>
    <parameter name="ping_timeout_sec" unique="0" required="1">
      <longdesc lang="en">Timeout for individual ping requests.</longdesc>
      <shortdesc lang="en">Ping timeout</shortdesc>
      <content type="integer" default="1"/>
    </parameter>
    <parameter name="ping_max_count" unique="0" required="1">
      <longdesc lang="en">Maximum number of addresses to test. These tests will continue until either a ping is successful or the maximum ping count is reached.</longdesc>
      <shortdesc lang="en">Maximum ping tests.</shortdesc>
      <content type="integer" default="10"/>
    </parameter>
  </parameters>
  <actions>
    <action name="start"/>
    <action name="stop"/>
    <action name="monitor"        timeout="15" interval="17" />
    <action name="meta-data"/>
    <action name="validate-all"/>
  </actions>
</resource-agent>
END
}

beegfs_monitor_start() {
  ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} start

  while true; do
    if check_resource_service; then
      return $OCF_SUCCESS
    fi
    sleep 0.5
  done
}

beegfs_monitor_stop() {
  ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} stop
}

# Validate BeeGFS service is running.
beegfs_monitor_monitor() {

  # Check resource tracking file.
  ha_pseudo_resource ${OCF_RESOURCE_INSTANCE} monitor
  ha_pseudo_resource_status=$?
  if [ $ha_pseudo_resource_status -ne $OCF_SUCCESS ]; then
    return $ha_pseudo_resource_status
  fi

  # Evaluate whether monitored resource has started systemd service (management, metadata or storage).
  declare -i retries=20
  declare -i filesystem_check=1
  declare -i network_check=1
  declare -i service_check=1
  while [ $retries -gt 0 ]; do
    retries=$retries-1

    if [ $filesystem_check -eq 1 ] && check_filesystem_mounts; then
      filesystem_check=0
    fi
    if [ $network_check -eq 1 ] && check_network_connectivity; then
      network_check=0
    fi
    if [ $service_check -eq 1 ] && check_resource_service; then
      service_check=0
    fi

    if [ $filesystem_check -eq 0 ] && [ $network_check -eq 0 ] && [ $service_check -eq 0 ]; then
      return $OCF_SUCCESS
    fi

    sleep 0.5
  done

  # Determine what failure occurred.
  if [ $filesystem_check -eq 1 ]; then
    ocf_exit_reason "Filesystem mount(s) are not active!"
  elif [ $network_check -eq 1 ]; then
    ocf_exit_reason "Network is not reachable!"
  elif [ $service_check -eq 1 ]; then
    ocf_exit_reason "Service is not active!"
  fi

  return $OCF_ERR_GENERIC
}

# Validate beegfs-monitor requirements
beegfs_monitor_validate_all() {
  return $OCF_SUCCESS
}

###############################################################################

# Provide information for metadata and usage requests
case $__OCF_ACTION in
  meta-data)
    beegfs_monitor_meta_data
    exit $OCF_SUCCESS
    ;;
  usage|help)
    beegfs_monitor_usage
    exit $OCF_SUCCESS
    ;;
esac


# Set argument variables
ping_count=${OCF_RESKEY_ping_count:-1}
ping_timeout=${OCF_RESKEY_ping_timeout_sec:-1}
ping_max_count=${OCF_RESKEY_ping_max_count:-10}
group=${OCF_RESKEY_service_group:-""}
type=${OCF_RESKEY_service_type:-""}
service=${OCF_RESKEY_service_name:-""}
configuration_mount=${OCF_RESKEY_service_configuration_mount:-""}
configuration_mount=${configuration_mount%%/}

case $type in
  management)
    conf_path="${configuration_mount}/mgmt_config/beegfs-mgmtd.conf"
    ;;
  metadata)
    conf_path="${configuration_mount}/metadata_config/beegfs-meta.conf"
    ;;
  storage)
    conf_path="${configuration_mount}/storage_config/beegfs-storage.conf"
    ;;
  *)
    beegfs_monitor_usage
    exit $OCF_ERR_ARGS
    ;;
esac

# Perform action requests
case $__OCF_ACTION in
  start)
    beegfs_monitor_start
    exit $?
    ;;
  stop)
    beegfs_monitor_stop
    exit $?
    ;;
  monitor)
    beegfs_monitor_monitor
    exit $?
    ;;
  validate-all)
    beegfs_monitor_validate_all
    exit $?
    ;;
  *)
    beegfs_monitor_usage
    exit $OCF_ERR_UNIMPLEMENTED
    ;;
esac
